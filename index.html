<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>掷圣杯 - 潮汕老爷保号 (AI版)</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Ma+Shan+Zheng&display=swap');
        
        body {
            margin: 0;
            padding: 0;
            background-color: #1a1a1a;
            overflow: hidden;
            font-family: 'Courier New', Courier, monospace;
            touch-action: none;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        #game-container {
            position: relative;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            border: 4px solid #4a4a4a;
            width: 320px;
            height: 480px;
            background: #2C1E18;
            user-select: none;
            -webkit-user-select: none;
        }

        canvas {
            display: block;
            image-rendering: pixelated;
            width: 100%;
            height: 100%;
        }

        .scanlines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                to bottom,
                rgba(255,255,255,0),
                rgba(255,255,255,0) 50%,
                rgba(0,0,0,0.1) 50%,
                rgba(0,0,0,0.1)
            );
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 10;
        }

        #ui-layer {
            position: absolute;
            top: 20px;
            left: 0;
            width: 100%;
            text-align: center;
            pointer-events: none;
            z-index: 20;
            text-shadow: 2px 2px 0 #000;
        }

        .pixel-text {
            color: white;
            font-size: 20px;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .controls-hint {
            position: absolute;
            bottom: 10px;
            width: 100%;
            text-align: center;
            color: #aaa;
            font-size: 10px;
            pointer-events: none;
            z-index: 20;
            padding: 0 10px;
        }

        #mobile-controls {
            position: absolute;
            bottom: 30px;
            width: 100%;
            height: 100px;
            display: none;
            pointer-events: auto;
            z-index: 30;
            justify-content: space-between;
            padding: 0 20px;
            box-sizing: border-box;
        }

        .btn {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid white;
            color: white;
            font-family: inherit;
            font-weight: bold;
            border-radius: 8px;
            padding: 10px;
            user-select: none;
            backdrop-filter: blur(2px);
        }

        .btn:active {
            background: rgba(255, 255, 255, 0.4);
        }

        #btn-space {
            width: 100px;
            height: 60px;
            position: absolute;
            bottom: 0px;
            left: 50%;
            transform: translateX(-50%);
        }

        #btn-left {
            position: absolute;
            left: 20px;
            bottom: 10px;
            width: 60px;
            height: 60px;
        }

        #btn-right {
            position: absolute;
            right: 20px;
            bottom: 10px;
            width: 60px;
            height: 60px;
        }

        /* AI Feature UI */
        #ai-interaction-layer {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            z-index: 50;
            display: none;
            flex-direction: column;
            align-items: center;
            pointer-events: auto;
        }

        .ai-btn {
            background: linear-gradient(135deg, #FFD700, #DAA520);
            border: 3px solid #8B4513;
            color: #5d2800;
            padding: 12px 24px;
            font-family: 'Ma Shan Zheng', cursive;
            font-size: 20px;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 4px 0 #8B4513, 0 10px 20px rgba(0,0,0,0.5);
            transition: transform 0.1s, box-shadow 0.1s;
            text-decoration: none;
            display: inline-block;
            margin-top: 10px;
            user-select: none;
        }

        .ai-btn:active {
            transform: translateY(4px);
            box-shadow: 0 0 0 #8B4513, 0 5px 10px rgba(0,0,0,0.5);
        }

        .ai-btn span {
            display: inline-block;
            animation: sparkle 2s infinite;
        }

        @keyframes sparkle {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        /* Fortune Modal */
        #fortune-modal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            z-index: 100;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            box-sizing: border-box;
            backdrop-filter: blur(5px);
            pointer-events: auto;
        }

        .fortune-paper {
            background-color: #FFF0F5; /* Light pinkish paper */
            background-image: 
                linear-gradient(90deg, transparent 95%, #ffdde1 95%),
                linear-gradient(transparent 95%, #ffdde1 95%);
            background-size: 20px 20px;
            width: 100%;
            max-width: 280px;
            padding: 20px;
            border: 8px double #D93829;
            box-shadow: 0 0 30px rgba(217, 56, 41, 0.3);
            text-align: center;
            font-family: 'Ma Shan Zheng', cursive;
            position: relative;
            overflow-y: auto;
            max-height: 80%;
        }

        .fortune-title {
            color: #D93829;
            font-size: 24px;
            margin-bottom: 15px;
            border-bottom: 2px solid #D93829;
            padding-bottom: 5px;
        }

        .fortune-content {
            color: #333;
            font-size: 18px;
            line-height: 1.6;
            margin-bottom: 20px;
            white-space: pre-wrap;
        }

        .fortune-ai-comment {
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px dashed #D93829;
            font-size: 16px;
            color: #555;
            font-style: italic;
        }

        .close-btn {
            background: #333;
            color: white;
            border: none;
            padding: 10px 20px;
            margin-top: 15px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            border-radius: 5px;
        }
        
        .loading-spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 4px solid #FFD700;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin-bottom: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

    </style>
</head>
<body>

    <div id="game-container">
        <div class="scanlines"></div>
        <div id="ui-layer">
            <div id="status-text" class="pixel-text">按住空格蓄力</div>
        </div>
        
        <!-- AI Interaction Layer -->
        <div id="ai-interaction-layer">
            <button id="btn-ask-ai" class="ai-btn">✨ 老爷赐示 ✨</button>
        </div>

        <canvas id="gameCanvas" width="320" height="480"></canvas>
        
        <div class="controls-hint">
            电脑: [空格] 蓄力/重来 | [←/→] 翻转<br>
            手机: 使用屏幕下方按钮
        </div>
        
        <div id="mobile-controls">
            <button id="btn-left" class="btn">←</button>
            <button id="btn-space" class="btn">掷</button>
            <button id="btn-right" class="btn">→</button>
        </div>

        <!-- Fortune Modal -->
        <div id="fortune-modal">
            <div id="loading-view" style="display:none; flex-direction:column; align-items:center; color:white;">
                <div class="loading-spinner"></div>
                <div style="font-family: 'Ma Shan Zheng'; font-size: 20px;" id="loading-text">老爷正在斟酌...</div>
            </div>
            
            <div id="result-view" class="fortune-paper" style="display:none;">
                <div class="fortune-title" id="fortune-title">上上签</div>
                <div class="fortune-content" id="fortune-text">
                    <!-- content -->
                </div>
                <div class="fortune-ai-comment" id="fortune-ai-comment" style="display:none;">
                    <!-- AI analysis will appear here -->
                </div>
                <button class="close-btn" onclick="closeModal()">收下签文</button>
            </div>
        </div>
    </div>

<script>
/**
 * 掷圣杯 Game Logic
 * Pixel Art Style + Delta Time Physics
 */

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const statusText = document.getElementById('status-text');
const aiLayer = document.getElementById('ai-interaction-layer');
const aiButton = document.getElementById('btn-ask-ai');
const fortuneModal = document.getElementById('fortune-modal');
const loadingView = document.getElementById('loading-view');
const loadingText = document.getElementById('loading-text');
const resultView = document.getElementById('result-view');
const fortuneTitle = document.getElementById('fortune-title');
const fortuneText = document.getElementById('fortune-text');
const fortuneAiComment = document.getElementById('fortune-ai-comment');

// Gemini API Configuration
const apiKey = ""; // System will provide API key at runtime

// Handle High DPI
const GAME_WIDTH = 320;
const GAME_HEIGHT = 480;

canvas.width = GAME_WIDTH * 2;
canvas.height = GAME_HEIGHT * 2;

// Enum
const STATE = {
    START: 0,
    CHARGING: 1,
    THROWN: 2,
    BOUNCING: 3,
    RESULT: 4
};

// Colors
const COLORS = {
    bg: '#2C1E18',
    gold: '#FFD700',
    red: '#D93829', 
    wood: '#E5C087',
    skin: '#E8B796',
    altar: '#8B4513',
    shadow: 'rgba(0,0,0,0.5)'
};

// Physics Variables
let gameState = STATE.START;
let animTime = 0; // Replaces 'frames' for animation timing
let chargePower = 0;
let chargeDir = 1;
let resultType = ""; 

// Physics Constants (Calibrated for 60FPS)
const GRAVITY = 0.15; 
const FLOOR_Y = 380; 

const cups = {
    left: { x: 0, y: 0, vx: 0, vy: 0, rot: 0, rotSpeed: 0, isFlat: false },
    right: { x: 0, y: 0, vx: 0, vy: 0, rot: 0, rotSpeed: 0, isFlat: false }
};

const keys = { space: false, left: false, right: false };
let particles = [];
let currentFortune = null; 

// --- Fixed Fortunes Database ---
const FORTUNES = [
    { title: "第一签 大吉", poem: "七层宝塔周周围，\n几多神仙下界来。\n今日龙楼把宴会，\n想君财帛自天来。" },
    { title: "第二签 上吉", poem: "枯木逢春色更鲜，\n主公欢喜地生连。\n如今喜得天赐福，\n祸去灾消福禄全。" },
    { title: "第三签 中平", poem: "一点丹心以此为，\n长江风浪不须推。\n目前只管勤耕作，\n日后荣华自然回。" },
    { title: "第四签 上吉", poem: "日出东方满天红，\n愁云消散见青空。\n此时百事皆如意，\n名利双收显威风。" },
    { title: "第五签 中下", poem: "乌云遮月暗朦胧，\n行船遇浪打头风。\n此时若问心中事，\n恰似推车上险峰。" },
    { title: "第六签 下下", poem: "风中烛火影摇红，\n夜半行船遇打头。\n只好守旧随缘过，\n免得劳心转更加。" },
    { title: "第七签 大吉", poem: "鹏鸟高飞千万里，\n一朝得志上青云。\n若问功名财利事，\n恰如锦上又添花。" },
    { title: "第八签 中平", poem: "行船把舵要在中，\n不须使力与使功。\n潮水来时风又顺，\n自然载得宝归篷。" }
];

// --- Xiaobei & Wenbei Messages ---
const XIAOBEI_MSGS = [
    "心中有数，何必问我？",
    "笑而不语，机缘未到。",
    "弟子，此事不必再问。",
    "莫强求，顺其自然。",
    "此卦为笑，意在言外。",
    "你其实已经知道答案了。",
    "问题太模糊，老爷听不懂。",
    "且放宽心，一笑置之。"
];

const WENBEI_MSGS = [
    "时运未至，切勿妄动。",
    "心诚则灵，杂念太重。",
    "此路不通，另寻他法。",
    "天机不可泄露。",
    "暂守本分，勿生贪念。",
    "老爷在忙，改日再来。",
    "此事不可为，慎之。",
    "静心修德，福报自来。"
];

// --- Gemini AI Logic ---
async function callGemini(type) {
    fortuneModal.style.display = 'flex';
    loadingView.style.display = 'flex';
    resultView.style.display = 'none';
    fortuneAiComment.style.display = 'none';
    
    const loadingTexts = ["老爷正在查阅天书...", "香烟袅袅，沟通天庭...", "老爷正在斟酌...", "圣杯落地，神机显现..."];
    loadingText.innerText = loadingTexts[Math.floor(Math.random() * loadingTexts.length)];

    let prompt = "";
    
    if (type === "SHENGBEI") {
        const randomIndex = Math.floor(Math.random() * FORTUNES.length);
        currentFortune = FORTUNES[randomIndex];
        fortuneTitle.innerText = "✨ " + currentFortune.title + " ✨";
        fortuneText.innerText = currentFortune.poem;
        prompt = `You are 'Lao Ye' (老爷), a wise Chaoshan deity. A believer drew the fortune sign: "${currentFortune.title}" with the poem: "${currentFortune.poem.replace(/\n/g, ', ')}". Provide a brief, wise, warm interpretation (解签) in Chinese (<60 words). Tone: Ancient, protective.`;
    } else if (type === "XIAOBEI") {
        const randomIndex = Math.floor(Math.random() * XIAOBEI_MSGS.length);
        const msg = XIAOBEI_MSGS[randomIndex];
        fortuneTitle.innerText = "☁️ 老爷笑了 ☁️";
        fortuneText.innerText = msg;
        prompt = `You are 'Lao Ye'. Believer threw 'Xiaobei'. You said: "${msg}". Briefly explain why in humorous/kind way (Chinese <40 words).`;
    } else {
        const randomIndex = Math.floor(Math.random() * WENBEI_MSGS.length);
        const msg = WENBEI_MSGS[randomIndex];
        fortuneTitle.innerText = "⛰️ 老爷不语 ⛰️";
        fortuneText.innerText = msg;
        prompt = `You are 'Lao Ye'. Believer threw 'Wenbei'. You said: "${msg}". Briefly explain why in stern/authoritative way (Chinese <40 words).`;
    }

    try {
        if (!apiKey) {
            loadingView.style.display = 'none';
            resultView.style.display = 'block';
            if (type === "SHENGBEI") {
                 fortuneAiComment.innerText = "(老爷正在闭关，暂无法解签，请自行感悟)";
                 fortuneAiComment.style.display = 'block';
            }
            return;
        }

        const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
        });

        const data = await response.json();
        if (data.error) throw new Error(data.error.message);
        
        const text = data.candidates[0].content.parts[0].text;
        loadingView.style.display = 'none';
        resultView.style.display = 'block';
        fortuneAiComment.innerText = "【老爷神示】\n" + text;
        fortuneAiComment.style.display = 'block';

    } catch (error) {
        console.error(error);
        loadingView.style.display = 'none';
        resultView.style.display = 'block';
        fortuneAiComment.innerText = "(老爷信号不佳，请以此签文/神谕为准)";
        fortuneAiComment.style.display = 'block';
    }
}

function closeModal() {
    fortuneModal.style.display = 'none';
}

aiButton.addEventListener('click', (e) => {
    e.stopPropagation();
    callGemini(resultType);
});


// --- Pixel Art Drawing ---
function drawRect(x, y, w, h, color) {
    ctx.fillStyle = color;
    ctx.fillRect(Math.floor(x), Math.floor(y), w, h);
}

// 12x12 Pixel Grid for Shengbei
const SHENGBEI_PIXELS = {
    flat: [
        [0,0,0,1,1,1,1,1,0,0,0,0], [0,0,1,1,1,2,2,2,1,0,0,0], [0,1,1,1,2,2,2,2,1,1,0,0],
        [1,1,1,1,2,2,2,2,1,1,1,0], [1,1,1,1,1,1,1,1,1,1,1,0], [1,1,1,1,0,0,0,0,1,1,1,0],
        [1,1,1,0,0,0,0,0,0,1,1,0], [1,1,0,0,0,0,0,0,0,1,1,0], [1,0,0,0,0,0,0,0,0,0,1,0],
        [0,0,0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0,0,0]
    ],
    round: [
        [0,0,0,1,1,1,1,1,0,0,0,0], [0,0,1,1,1,1,1,1,1,0,0,0], [0,1,1,1,2,2,1,1,1,1,0,0],
        [1,1,1,2,2,2,2,1,1,1,1,0], [1,1,1,2,2,2,2,1,1,1,1,0], [1,1,1,1,1,1,1,1,1,1,1,0],
        [1,1,1,0,0,0,0,0,0,1,1,0], [1,1,0,0,0,0,0,0,0,1,1,0], [1,0,0,0,0,0,0,0,0,0,1,0],
        [0,0,0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0,0,0]
    ],
    side: [
        [0,0,0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,0], [0,1,1,1,1,1,1,1,1,1,0,0], [1,1,1,1,1,1,1,1,1,1,1,0],
        [1,1,0,0,0,0,0,0,0,1,1,0], [1,0,0,0,0,0,0,0,0,0,1,0], [0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0,0,0]
    ]
};

function drawPixelSprite(x, y, grid, colorMap, scale = 2, rot = 0) {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(rot);
    const offset = 6 * scale;
    for(let r=0; r<12; r++) {
        for(let c=0; c<12; c++) {
            const val = grid[r][c];
            if(val > 0) {
                ctx.fillStyle = colorMap[val];
                ctx.fillRect(c * scale - offset, r * scale - offset, scale, scale);
            }
        }
    }
    ctx.restore();
}

function drawLaoYe() {
    const cx = GAME_WIDTH / 2;
    const cy = 120;
    ctx.save();
    ctx.scale(2, 2);

    // Aura
    ctx.globalAlpha = 0.2 + Math.sin(animTime * 0.05) * 0.1;
    ctx.beginPath();
    ctx.arc(cx, cy, 60, 0, Math.PI * 2);
    ctx.fillStyle = COLORS.gold;
    ctx.fill();
    ctx.globalAlpha = 1.0;

    // Body
    drawRect(cx - 30, cy, 60, 80, '#A62619');
    drawRect(cx - 10, cy, 20, 80, COLORS.gold);
    drawRect(cx - 40, cy + 5, 10, 30, '#801A10');
    drawRect(cx + 30, cy + 5, 10, 30, '#801A10');
    // Head
    drawRect(cx - 15, cy - 35, 30, 35, '#E8C0A0');
    drawRect(cx - 15, cy - 35, 30, 10, 'black');
    drawRect(cx - 10, cy - 45, 20, 10, COLORS.gold);
    // Beard
    drawRect(cx - 10, cy - 5, 20, 25, 'white');
    drawRect(cx - 5, cy + 20, 10, 15, '#ddd');
    // Eyes
    drawRect(cx - 8, cy - 20, 4, 2, 'black');
    drawRect(cx + 4, cy - 20, 4, 2, 'black');
    // Table
    drawRect(0, 250, GAME_WIDTH, 100, COLORS.altar);
    // Incense
    drawRect(cx - 20, 240, 40, 20, '#CD7F32');
    drawRect(cx - 15, 235, 30, 5, '#A0522D');
    drawRect(cx - 5, 215, 2, 20, '#D2691E');
    drawRect(cx, 210, 2, 25, '#D2691E');
    drawRect(cx + 5, 215, 2, 20, '#D2691E');

    // Smoke (Time based spawn)
    if (Math.floor(animTime) % 4 === 0) {
        // Simple rate limiter to avoid excessive particles at high FPS
        // Actually best to use a separate timer. 
        // For simplicity, we just randomly add particles
        if (Math.random() < 0.2) {
             particles.push({
                x: (cx * 2) + (Math.random() - 0.5) * 10,
                y: 420, 
                vx: (Math.random() - 0.5) * 0.5,
                vy: -0.5 - Math.random() * 0.5,
                life: 80,
                color: 'rgba(200,200,200,0.4)',
                size: 4 
            });
        }
    }

    ctx.restore();
}

function drawHands() {
    let yOffset = 0;
    if (gameState === STATE.CHARGING) yOffset = Math.sin(animTime * 0.8) * 2 + chargePower * 0.5;
    else if (gameState === STATE.THROWN) yOffset = 300; 
    else if (gameState === STATE.START) yOffset = Math.sin(animTime * 0.05) * 3;

    const lx = 80;
    const rx = 240;
    const by = 400 + yOffset;

    ctx.save();
    ctx.scale(2, 2);

    // Hands
    drawRect(lx - 20, by, 40, 40, COLORS.skin);
    drawRect(lx - 15, by - 5, 10, 20, COLORS.skin);
    drawRect(lx - 5, by - 10, 10, 20, COLORS.skin);
    drawRect(lx + 5, by - 8, 10, 18, COLORS.skin);
    drawRect(rx - 20, by, 40, 40, COLORS.skin);
    drawRect(rx + 5, by - 5, 10, 20, COLORS.skin);
    drawRect(rx - 5, by - 10, 10, 20, COLORS.skin);
    drawRect(rx - 15, by - 8, 10, 18, COLORS.skin);
    
    if (gameState === STATE.START || gameState === STATE.CHARGING) {
        const scale = 3;
        drawPixelSprite(lx + 5, by, SHENGBEI_PIXELS.side, {1: COLORS.red}, scale, -Math.PI/2);
        drawPixelSprite(rx - 5, by, SHENGBEI_PIXELS.side, {1: COLORS.red}, scale, Math.PI/2);
    }
    ctx.restore();
}

function drawPixelShengbei(cup) {
    let grid, colors;
    const scale = 3; 
    const rotation = cup.rot;
    
    let showFlat = false;
    if (cup.y >= FLOOR_Y && Math.abs(cup.vy) < 0.1) {
        showFlat = cup.isFlat;
    } else {
        const phase = Math.cos(rotation);
        showFlat = phase > 0;
    }

    if (Math.abs(Math.cos(rotation)) > 0.5) { 
        if (showFlat) {
            grid = SHENGBEI_PIXELS.flat;
            colors = {1: COLORS.wood, 2: '#F4D090'}; 
        } else {
            grid = SHENGBEI_PIXELS.round;
            colors = {1: COLORS.red, 2: '#FF5544'}; 
        }
    } else {
        grid = SHENGBEI_PIXELS.side;
        colors = {1: COLORS.red};
    }
    drawPixelSprite(cup.x, cup.y, grid, colors, scale, rotation);
}

function updateParticles() {
    for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life--;
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x, p.y, p.size, p.size);
        if (p.life <= 0) particles.splice(i, 1);
    }
}

function createExplosion(x, y, color) {
    for(let i=0; i<15; i++) {
        particles.push({
            x: x * 2, 
            y: y * 2,
            vx: (Math.random() - 0.5) * 6,
            vy: (Math.random() - 0.5) * 6,
            life: 30,
            color: color,
            size: 6
        });
    }
}

// --- Game Logic (Physics) ---

function resetGame() {
    gameState = STATE.START;
    chargePower = 0;
    statusText.innerText = "按住空格蓄力";
    statusText.style.color = "white";
    aiLayer.style.display = 'none';
    resultType = "";
    currentFortune = null;
    cups.left = { x: 80, y: FLOOR_Y, vx: 0, vy: 0, rot: 0, rotSpeed: 0, isFlat: false };
    cups.right = { x: 240, y: FLOOR_Y, vx: 0, vy: 0, rot: 0, rotSpeed: 0, isFlat: false };
}

function throwCups() {
    gameState = STATE.THROWN;
    const power = 14 + (chargePower / 100) * 4; 
    
    cups.left.x = 80;
    cups.left.y = 400; 
    cups.left.vy = -power;
    cups.left.vx = 0.5 + Math.random() * 1.5; 
    cups.left.rotSpeed = 0.1 + Math.random() * 0.1;
    
    cups.right.x = 240;
    cups.right.y = 400;
    cups.right.vy = -power;
    cups.right.vx = -(0.5 + Math.random() * 1.5);
    cups.right.rotSpeed = -(0.1 + Math.random() * 0.1);
    
    statusText.innerText = "空中按 ← → 翻转!";
}

function checkResult() {
    const leftFlat = cups.left.isFlat;
    const rightFlat = cups.right.isFlat;
    
    setTimeout(() => {
        gameState = STATE.RESULT;
        aiLayer.style.display = 'flex'; 
        
        if (leftFlat !== rightFlat) {
            resultType = "SHENGBEI";
            statusText.innerText = "★ 胜杯！老爷保号 ★";
            statusText.style.color = "#FFD700";
            aiButton.innerText = "✨ 求支灵签 ✨";
            createExplosion(GAME_WIDTH/2, 150, COLORS.gold);
        } else if (!leftFlat && !rightFlat) {
            resultType = "WENBEI";
            statusText.innerText = "稳杯 (两凸/阴)";
            statusText.style.color = "#D93829";
            aiButton.innerText = "⛰️ 询问老爷 ⛰️";
        } else {
            resultType = "XIAOBEI";
            statusText.innerText = "笑杯 (两平/阳)";
            statusText.style.color = "#E5C087";
            aiButton.innerText = "☁️ 老爷为何发笑? ☁️";
        }
    }, 500);
}

// dt = Time Scaling factor. 1.0 at 60Hz. 0.5 at 120Hz.
function updatePhysics(dt) {
    if (gameState === STATE.THROWN || gameState === STATE.BOUNCING) {
        let settledCount = 0;
        [cups.left, cups.right].forEach((cup) => {
            // Apply Gravity (Scaled by dt)
            if (cup.y < FLOOR_Y) cup.vy += GRAVITY * dt;
            
            // Apply Velocity (Scaled by dt)
            cup.x += cup.vx * dt;
            cup.y += cup.vy * dt;
            cup.rot += cup.rotSpeed * dt;
            
            // Wall bounce
            if (cup.x < 30 || cup.x > GAME_WIDTH - 30) cup.vx *= -0.5;
            
            // Floor Collision
            if (cup.y >= FLOOR_Y) {
                cup.y = FLOOR_Y;
                if (Math.abs(cup.vy) > 1.5) { 
                    cup.vy *= -0.4; 
                    // Friction decay over time -> exponential decay per frame
                    // approximate for 60hz -> 0.8
                    cup.vx *= Math.pow(0.8, dt); 
                } else {
                    cup.vy = 0;
                    cup.vx = 0;
                    cup.rotSpeed = 0;
                    const phase = Math.cos(cup.rot);
                    cup.isFlat = phase > 0; 
                    cup.rot = cup.isFlat ? 0 : Math.PI; 
                }
            }
            if (cup.vy === 0 && cup.y === FLOOR_Y) settledCount++;
        });
        
        if (settledCount === 2 && gameState !== STATE.BOUNCING && gameState !== STATE.RESULT) {
            gameState = STATE.BOUNCING; 
            checkResult();
        }
    }
}

function flipCup(side) {
    if (gameState !== STATE.THROWN) return;
    const cup = side === 'left' ? cups.left : cups.right;
    cup.rotSpeed += (side === 'left' ? 0.3 : -0.3);
    cup.rot += Math.PI / 2; 
    // Impulse is instantaneous, does not need dt scaling
    cup.vy -= 2.5; 
    createExplosion(cup.x, cup.y, 'white'); 
}

function update(dt) {
    // Increment generic animation timer
    animTime += dt;

    if (gameState === STATE.START) {
        if (keys.space) {
            gameState = STATE.CHARGING;
            chargePower = 0;
        }
    } else if (gameState === STATE.CHARGING) {
        if (keys.space) {
            // Charging speed scaled by dt
            chargePower += chargeDir * 2 * dt;
            if (chargePower > 100 || chargePower < 0) chargeDir *= -1;
        } else {
            throwCups();
        }
    } else if (gameState === STATE.RESULT) {
        if (keys.space && fortuneModal.style.display === 'none') {
            resetGame();
            keys.space = false;
        }
    }
    updatePhysics(dt);
}

function draw() {
    ctx.fillStyle = COLORS.bg;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    drawLaoYe(); 
    drawHands(); 
    if (gameState !== STATE.START && gameState !== STATE.CHARGING) {
        ctx.save();
        ctx.scale(2, 2);
        ctx.fillStyle = COLORS.shadow;
        [cups.left, cups.right].forEach(c => {
            const shadowScale = 1 - (FLOOR_Y - c.y)/300; 
            if (shadowScale > 0) {
                ctx.beginPath();
                ctx.ellipse(c.x, FLOOR_Y + 12, 12 * shadowScale, 6 * shadowScale, 0, 0, Math.PI*2);
                ctx.fill();
            }
        });
        drawPixelShengbei(cups.left);
        drawPixelShengbei(cups.right);
        ctx.restore();
    }
    if (gameState === STATE.CHARGING) {
        ctx.save();
        ctx.scale(2, 2);
        ctx.fillStyle = '#555';
        ctx.fillRect(110, 350, 100, 10);
        ctx.fillStyle = '#ff0';
        ctx.fillRect(110, 350, chargePower, 10);
        ctx.strokeStyle = '#fff';
        ctx.strokeRect(110, 350, 100, 10);
        ctx.restore();
    }
    updateParticles(); 
}

// Inputs
window.addEventListener('keydown', e => {
    if (e.code === 'Space') keys.space = true;
    if (e.code === 'ArrowLeft') { keys.left = true; flipCup('left'); }
    if (e.code === 'ArrowRight') { keys.right = true; flipCup('right'); }
});
window.addEventListener('keyup', e => {
    if (e.code === 'Space') keys.space = false;
    if (e.code === 'ArrowLeft') keys.left = false;
    if (e.code === 'ArrowRight') keys.right = false;
});
const handleTouch = (keyName, isDown) => {
    if (keyName === 'space') {
        keys.space = isDown;
        if(isDown && gameState === STATE.RESULT && fortuneModal.style.display === 'none') {
            resetGame();
            keys.space = false;
        }
    }
    if (keyName === 'left' && isDown) flipCup('left');
    if (keyName === 'right' && isDown) flipCup('right');
};
if ('ontouchstart' in window) document.getElementById('mobile-controls').style.display = 'flex';
document.getElementById('btn-space').addEventListener('touchstart', (e) => { e.preventDefault(); handleTouch('space', true); });
document.getElementById('btn-space').addEventListener('touchend', (e) => { e.preventDefault(); handleTouch('space', false); });
document.getElementById('btn-left').addEventListener('touchstart', (e) => { e.preventDefault(); handleTouch('left', true); });
document.getElementById('btn-right').addEventListener('touchstart', (e) => { e.preventDefault(); handleTouch('right', true); });

// --- New Loop with Delta Time ---
let lastTime = 0;
function loop(timestamp) {
    if (!lastTime) lastTime = timestamp;
    
    // Calculate delta time in ms
    let deltaTime = timestamp - lastTime;
    
    // Cap deltaTime to prevent huge jumps (e.g. switching tabs)
    if (deltaTime > 50) deltaTime = 50;
    
    lastTime = timestamp;

    // Calculate timeScale (1.0 = 60fps)
    const timeScale = deltaTime / 16.67;

    update(timeScale);
    draw();
    
    requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

</script>
</body>
</html>
