<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Êé∑Âú£ÊùØ - ÊΩÆÊ±ïËÄÅÁà∑‰øùÂè∑</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Ma+Shan+Zheng&display=swap');
        
        body {
            margin: 0;
            padding: 0;
            background-color: #1a1a1a;
            overflow: hidden;
            font-family: 'Courier New', Courier, monospace;
            touch-action: none;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        #game-container {
            position: relative;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            border: 4px solid #4a4a4a;
            width: 320px;
            height: 480px;
            background: #2C1E18;
            user-select: none;
            -webkit-user-select: none;
        }

        canvas {
            display: block;
            image-rendering: pixelated;
            width: 100%;
            height: 100%;
        }

        .scanlines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                to bottom,
                rgba(255,255,255,0),
                rgba(255,255,255,0) 50%,
                rgba(0,0,0,0.1) 50%,
                rgba(0,0,0,0.1)
            );
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 10;
        }

        #ui-layer {
            position: absolute;
            top: 20px;
            left: 0;
            width: 100%;
            text-align: center;
            pointer-events: none;
            z-index: 20;
            text-shadow: 2px 2px 0 #000;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .pixel-text {
            color: white;
            font-size: 20px;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .sub-text {
            color: #FFD700;
            font-size: 14px;
            margin-top: 5px;
            opacity: 0.9;
            background: rgba(0,0,0,0.6);
            padding: 4px 8px;
            border-radius: 4px;
            display: inline-block;
            font-family: 'Ma Shan Zheng', cursive;
        }

        /* Wish Input Styling */
        #wish-input {
            margin-top: 10px;
            width: 220px;
            background: rgba(0, 0, 0, 0.4);
            border: 2px solid #8B4513;
            border-radius: 8px;
            padding: 8px;
            color: #FFD700;
            font-family: 'Ma Shan Zheng', cursive;
            font-size: 16px;
            text-align: center;
            outline: none;
            pointer-events: auto; /* Enable typing */
            transition: all 0.3s ease;
        }

        #wish-input::placeholder {
            color: rgba(255, 215, 0, 0.5);
        }

        #wish-input:focus {
            background: rgba(0, 0, 0, 0.7);
            border-color: #FFD700;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
        }

        .controls-hint {
            position: absolute;
            bottom: 10px;
            width: 100%;
            text-align: center;
            color: #aaa;
            font-size: 10px;
            pointer-events: none;
            z-index: 20;
            padding: 0 10px;
        }

        #mobile-controls {
            position: absolute;
            bottom: 30px;
            width: 100%;
            height: 100px;
            display: none;
            pointer-events: auto;
            z-index: 30;
            justify-content: space-between;
            padding: 0 20px;
            box-sizing: border-box;
        }

        .btn {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid white;
            color: white;
            font-family: inherit;
            font-weight: bold;
            border-radius: 8px;
            padding: 10px;
            user-select: none;
            backdrop-filter: blur(2px);
        }

        .btn:active {
            background: rgba(255, 255, 255, 0.4);
        }

        #btn-space {
            width: 100px;
            height: 60px;
            position: absolute;
            bottom: 0px;
            left: 50%;
            transform: translateX(-50%);
        }

        #btn-left {
            position: absolute;
            left: 20px;
            bottom: 10px;
            width: 60px;
            height: 60px;
        }

        #btn-right {
            position: absolute;
            right: 20px;
            bottom: 10px;
            width: 60px;
            height: 60px;
        }

        #settings-btn {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 30px;
            height: 30px;
            z-index: 40;
            background: rgba(0,0,0,0.3);
            border: 1px solid #666;
            border-radius: 4px;
            color: #ccc;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            font-size: 16px;
            pointer-events: auto;
        }

        /* AI Feature UI */
        #ai-interaction-layer {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            z-index: 50;
            display: none;
            flex-direction: column;
            align-items: center;
            pointer-events: auto;
        }

        .ai-btn {
            background: linear-gradient(135deg, #FFD700, #DAA520);
            border: 3px solid #8B4513;
            color: #5d2800;
            padding: 12px 24px;
            font-family: 'Ma Shan Zheng', cursive;
            font-size: 20px;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 4px 0 #8B4513, 0 10px 20px rgba(0,0,0,0.5);
            transition: transform 0.1s, box-shadow 0.1s;
            text-decoration: none;
            display: inline-block;
            margin-top: 10px;
            user-select: none;
        }

        .ai-btn:active {
            transform: translateY(4px);
            box-shadow: 0 0 0 #8B4513, 0 5px 10px rgba(0,0,0,0.5);
        }

        .ai-btn span {
            display: inline-block;
            animation: sparkle 2s infinite;
        }

        @keyframes sparkle {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        /* Modals */
        .modal-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            z-index: 100;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            box-sizing: border-box;
            backdrop-filter: blur(5px);
            pointer-events: auto;
        }

        .fortune-paper {
            background-color: #FFF0F5;
            background-image: 
                linear-gradient(90deg, transparent 95%, #ffdde1 95%),
                linear-gradient(transparent 95%, #ffdde1 95%);
            background-size: 20px 20px;
            width: 100%;
            max-width: 280px;
            padding: 20px;
            border: 8px double #D93829;
            box-shadow: 0 0 30px rgba(217, 56, 41, 0.3);
            text-align: center;
            font-family: 'Ma Shan Zheng', cursive;
            position: relative;
            overflow-y: auto;
            max-height: 80%;
        }

        .settings-paper {
            background-color: #333;
            width: 100%;
            max-width: 280px;
            padding: 20px;
            border: 2px solid #666;
            color: white;
            text-align: center;
            font-family: 'Courier New', monospace;
        }

        .fortune-title {
            color: #D93829;
            font-size: 24px;
            margin-bottom: 15px;
            border-bottom: 2px solid #D93829;
            padding-bottom: 5px;
        }

        .fortune-content {
            color: #333;
            font-size: 18px;
            line-height: 1.6;
            margin-bottom: 20px;
            white-space: pre-wrap;
        }

        .fortune-ai-comment {
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px dashed #D93829;
            font-size: 16px;
            color: #555;
            font-style: italic;
        }

        .close-btn {
            background: #333;
            color: white;
            border: none;
            padding: 10px 20px;
            margin-top: 15px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            border-radius: 5px;
        }

        .input-key {
            width: 100%;
            padding: 8px;
            margin: 10px 0;
            background: #111;
            border: 1px solid #555;
            color: white;
            font-family: monospace;
            box-sizing: border-box;
        }
        
        .loading-spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 4px solid #FFD700;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin-bottom: 10px;
        }

        .key-status {
            font-size: 10px;
            margin-bottom: 5px;
            text-align: left;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

    </style>
</head>
<body>

    <div id="game-container">
        <div class="scanlines"></div>
        <button id="settings-btn" title="API ËÆæÁΩÆ">‚öôÔ∏è</button>
        <div id="ui-layer">
            <div id="status-text" class="pixel-text">Êåâ‰ΩèÁ©∫Ê†ºËìÑÂäõ</div>
            <div id="sub-text" class="sub-text" style="display:none;">Á©∫‰∏≠Ë∞ÉÊï¥ÔºåÂáëÊàê [Âπ≥] + [Âá∏] ‰∏∫ËÉú</div>
            <!-- Wish Input Field -->
            <input type="text" id="wish-input" placeholder="Âú®Ê≠§ÈªòÂøµÂøÉ‰∏≠ÊâÄÊ±Ç..." maxlength="20">
        </div>
        
        <!-- AI Interaction Layer -->
        <div id="ai-interaction-layer">
            <button id="btn-ask-ai" class="ai-btn">‚ú® ËÄÅÁà∑ËµêÁ§∫ ‚ú®</button>
        </div>

        <canvas id="gameCanvas" width="320" height="480"></canvas>
        
        <div class="controls-hint">
            ÁîµËÑë: [Á©∫Ê†º] ËìÑÂäõ/ÈáçÊù• | [‚Üê/‚Üí] ÁøªËΩ¨<br>
            ÊâãÊú∫: ‰ΩøÁî®Â±èÂπï‰∏ãÊñπÊåâÈíÆ
        </div>
        
        <div id="mobile-controls">
            <button id="btn-left" class="btn">‚Üê</button>
            <button id="btn-space" class="btn">Êé∑</button>
            <button id="btn-right" class="btn">‚Üí</button>
        </div>

        <!-- Fortune Modal -->
        <div id="fortune-modal" class="modal-overlay">
            <div id="loading-view" style="display:none; flex-direction:column; align-items:center; color:white;">
                <div class="loading-spinner"></div>
                <div style="font-family: 'Ma Shan Zheng'; font-size: 20px;" id="loading-text">ËÄÅÁà∑Ê≠£Âú®ÊñüÈÖå...</div>
            </div>
            
            <div id="result-view" class="fortune-paper" style="display:none;">
                <div class="fortune-title" id="fortune-title">‰∏ä‰∏äÁ≠æ</div>
                <div class="fortune-content" id="fortune-text"></div>
                <div class="fortune-ai-comment" id="fortune-ai-comment" style="display:none;"></div>
                <button class="close-btn" onclick="closeFortuneModal()">Êî∂‰∏ãÁ≠æÊñá</button>
            </div>
        </div>

        <!-- Settings Modal -->
        <div id="settings-modal" class="modal-overlay">
            <div class="settings-paper">
                <h3>ËÆæÁΩÆ / Settings</h3>
                <div id="key-status-display" class="key-status"></div>
                <p style="font-size:12px; color:#aaa; margin-bottom: 5px;">ËØ∑ËæìÂÖ•ÊÇ®ÁöÑ DeepSeek / Gemini API Key:</p>
                <input type="password" id="api-key-input" class="input-key" placeholder="sk-...">
                <button class="close-btn" onclick="saveSettings()">‰øùÂ≠òÈÖçÁΩÆ</button>
                <button class="close-btn" onclick="clearSettings()" style="background:#555; margin-top:5px;">ÊÅ¢Â§çÈªòËÆ§</button>
                <button class="close-btn" onclick="closeSettingsModal()" style="background:transparent; border:1px solid #555; margin-top:15px;">ÂÖ≥Èó≠</button>
                <br><br>
                <div style="font-size:10px; color:#aaa;">
                    Êé®Ëçê‰ΩøÁî® <a href="https://platform.deepseek.com/" target="_blank" style="color:#FFD700;">DeepSeek</a> (ÂõΩÂÜÖÂèØÁî®) <br>
                    Êàñ Google Gemini (ÈúÄÈ≠îÊ≥ï)
                </div>
            </div>
        </div>
    </div>

<script>
/**
 * Êé∑Âú£ÊùØÔºöËÄÅÁà∑‰øùÂè∑ - Final Release (Domestic Friendly)
 */

// ==========================================================
// „ÄêÈÖçÁΩÆÂå∫Âüü„ÄëËØ∑Âú®‰∏ãÊñπÂ°´ÂÖ•ÊÇ®ÁöÑ API Key
// Êé®Ëçê‰ΩøÁî® DeepSeek API (ÂõΩÂÜÖÁõ¥Ëøû) Êàñ Google Gemini
// ==========================================================
const DEFAULT_CONFIG = {
    // ÈªòËÆ§‰ΩøÁî® DeepSeek (ÂõΩÂÜÖÊúÄÁ®≥)
    // Áî≥ËØ∑Âú∞ÂùÄ: https://platform.deepseek.com/
    apiUrl: "https://api.deepseek.com/chat/completions",
    model: "deepseek-chat",
    key: "sk-90bf60a9f9424f79bf3350983e008fcf" // <--- ËØ∑Âú®Ê≠§Â§ÑÂèåÂºïÂè∑ÂÜÖÁ≤òË¥¥ÊÇ®ÁöÑ DeepSeek API Key (sk-ÂºÄÂ§¥)
};
// ==========================================================

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const statusText = document.getElementById('status-text');
const subText = document.getElementById('sub-text');
const wishInput = document.getElementById('wish-input'); 
const aiLayer = document.getElementById('ai-interaction-layer');
const aiButton = document.getElementById('btn-ask-ai');
const fortuneModal = document.getElementById('fortune-modal');
const settingsModal = document.getElementById('settings-modal');
const loadingView = document.getElementById('loading-view');
const loadingText = document.getElementById('loading-text');
const resultView = document.getElementById('result-view');
const fortuneTitle = document.getElementById('fortune-title');
const fortuneText = document.getElementById('fortune-text');
const fortuneAiComment = document.getElementById('fortune-ai-comment');
const settingsBtn = document.getElementById('settings-btn');
const apiKeyInput = document.getElementById('api-key-input');
const keyStatusDisplay = document.getElementById('key-status-display');

// --- Key Management Logic ---
let customApiKey = localStorage.getItem('shengbei_api_key') || "";

updateKeyStatus(!!customApiKey);

function updateKeyStatus(hasCustom) {
    if (hasCustom) {
        keyStatusDisplay.innerHTML = "üîß ÂΩìÂâç‰ΩøÁî®: Ëá™ÂÆö‰πâ Key";
        keyStatusDisplay.style.color = "#FFD700";
    } else {
        if (DEFAULT_CONFIG.key && DEFAULT_CONFIG.key.length > 5) {
            keyStatusDisplay.innerHTML = "‚úÖ ÂΩìÂâç‰ΩøÁî®: ÈªòËÆ§ Key (Â∑≤ÈÖçÁΩÆ)";
            keyStatusDisplay.style.color = "#4CAF50";
        } else {
            keyStatusDisplay.innerHTML = "‚ö†Ô∏è Êú™ÈÖçÁΩÆ Key (AIÂäüËÉΩ‰∏çÂèØÁî®)";
            keyStatusDisplay.style.color = "#FF4444";
        }
    }
}

function getEffectiveKey() {
    return customApiKey && customApiKey.trim().length > 0 ? customApiKey : DEFAULT_CONFIG.key;
}

function showSettings() {
    apiKeyInput.value = customApiKey; 
    settingsModal.style.display = 'flex';
}

function closeSettingsModal() {
    settingsModal.style.display = 'none';
}

function saveSettings() {
    const input = apiKeyInput.value.trim();
    if (input.length > 0) {
        customApiKey = input;
        localStorage.setItem('shengbei_api_key', customApiKey);
        updateKeyStatus(true);
        alert("Key Â∑≤‰øùÂ≠òÔºÅ");
    } else {
        clearSettings();
    }
    settingsModal.style.display = 'none';
}

function clearSettings() {
    customApiKey = "";
    apiKeyInput.value = "";
    localStorage.removeItem('shengbei_api_key');
    updateKeyStatus(false);
}

settingsBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    showSettings();
});

// Prevent spacebar from triggering throw when typing wish
wishInput.addEventListener('keydown', (e) => {
    e.stopPropagation();
});

// Handle High DPI
const GAME_WIDTH = 320;
const GAME_HEIGHT = 480;

canvas.width = GAME_WIDTH * 2;
canvas.height = GAME_HEIGHT * 2;

const STATE = {
    START: 0,
    CHARGING: 1,
    THROWN: 2,
    BOUNCING: 3,
    RESULT: 4
};

const COLORS = {
    bg: '#2C1E18',
    gold: '#FFD700',
    red: '#D93829', 
    wood: '#E5C087',
    skin: '#E8B796',
    altar: '#8B4513',
    shadow: 'rgba(0,0,0,0.5)',
    auraGold: 'rgba(255, 215, 0, 0.4)', 
    auraRed: 'rgba(217, 56, 41, 0.4)'
};

let gameState = STATE.START;
let animTime = 0; 
let chargePower = 0;
let chargeDir = 1;
let resultType = ""; 

const GRAVITY = 0.15; 
const FLOOR_Y = 380; 

const cups = {
    left: { x: 0, y: 0, vx: 0, vy: 0, rot: 0, rotSpeed: 0, isFlat: false },
    right: { x: 0, y: 0, vx: 0, vy: 0, rot: 0, rotSpeed: 0, isFlat: false }
};

const keys = { space: false, left: false, right: false };
let particles = [];
let currentFortune = null; 

// --- Fixed Fortunes Database (Optimized) ---
const FORTUNES = [
    { title: "Á¨¨‰∏ÄÁ≠æ Â§ßÂêâ", poem: "‰∏ÉÂ±ÇÂÆùÂ°îÂë®Âë®Âõ¥Ôºå\nÂá†Â§öÁ•û‰ªô‰∏ãÁïåÊù•„ÄÇ\n‰ªäÊó•ÈæôÊ•ºÊääÂÆ¥‰ºöÔºå\nÊÉ≥ÂêõË¥¢Â∏õËá™Â§©Êù•„ÄÇ" },
    { title: "Á¨¨‰∫åÁ≠æ ‰∏äÂêâ", poem: "ÊûØÊú®ÈÄ¢Êò•Ëâ≤Êõ¥È≤úÔºå\n‰∏ªÂÖ¨Ê¨¢ÂñúÂú∞ÁîüËøû„ÄÇ\nÂ¶Ç‰ªäÂñúÂæóÂ§©ËµêÁ¶èÔºå\nÁ•∏ÂéªÁÅæÊ∂àÁ¶èÁ¶ÑÂÖ®„ÄÇ" },
    { title: "Á¨¨‰∏âÁ≠æ ‰∏≠Âπ≥", poem: "‰∏ÄÁÇπ‰∏πÂøÉ‰ª•Ê≠§‰∏∫Ôºå\nÈïøÊ±üÈ£éÊµ™‰∏çÈ°ªÊé®„ÄÇ\nÁõÆÂâçÂè™ÁÆ°Âã§ËÄï‰ΩúÔºå\nÊó•ÂêéËç£ÂçéËá™ÁÑ∂Âõû„ÄÇ" },
    { title: "Á¨¨ÂõõÁ≠æ ‰∏äÂêâ", poem: "Êó•Âá∫‰∏úÊñπÊª°Â§©Á∫¢Ôºå\nÊÑÅ‰∫ëÊ∂àÊï£ËßÅÈùíÁ©∫„ÄÇ\nÊ≠§Êó∂Áôæ‰∫ãÁöÜÂ¶ÇÊÑèÔºå\nÂêçÂà©ÂèåÊî∂ÊòæÂ®ÅÈ£é„ÄÇ" },
    { title: "Á¨¨‰∏ÉÁ≠æ Â§ßÂêâ", poem: "ÈπèÈ∏üÈ´òÈ£ûÂçÉ‰∏áÈáåÔºå\n‰∏ÄÊúùÂæóÂøó‰∏äÈùí‰∫ë„ÄÇ\nËã•ÈóÆÂäüÂêçË¥¢Âà©‰∫ãÔºå\nÊÅ∞Â¶ÇÈî¶‰∏äÂèàÊ∑ªËä±„ÄÇ" },
    { title: "Á¨¨ÂÖ´Á≠æ ‰∏≠Âπ≥", poem: "Ë°åËàπÊääËàµË¶ÅÂú®‰∏≠Ôºå\n‰∏çÈ°ª‰ΩøÂäõ‰∏é‰ΩøÂäü„ÄÇ\nÊΩÆÊ∞¥Êù•Êó∂È£éÂèàÈ°∫Ôºå\nËá™ÁÑ∂ËΩΩÂæóÂÆùÂΩíÁØ∑„ÄÇ" },
    { title: "Á¨¨‰πùÁ≠æ ‰∏ä‰∏ä", poem: "ÁôªÂ±±Ê∂âÊ∞¥Ê≠£Â§©Âè∞Ôºå\nÂ∞ëÂ∞èÂßªÁºòÈÄêÊ∏êÊù•„ÄÇ\nÊ≠§ÂéªË°å‰∫∫ÂæóÂà©‰æøÔºå\nË¥µ‰∫∫Êé•ÂºïÁ¨ëÈ¢úÂºÄ„ÄÇ" }
];

const XIAOBEI_MSGS = [
    "ÂøÉ‰∏≠ÊúâÊï∞Ôºå‰ΩïÂøÖÈóÆÊàëÔºü",
    "Á¨ëËÄå‰∏çËØ≠ÔºåÊú∫ÁºòÊú™Âà∞„ÄÇ",
    "ÂºüÂ≠êÔºåÊ≠§‰∫ã‰∏çÂøÖÂÜçÈóÆ„ÄÇ",
    "Ëé´Âº∫Ê±ÇÔºåÈ°∫ÂÖ∂Ëá™ÁÑ∂„ÄÇ",
    "Ê≠§Âç¶‰∏∫Á¨ëÔºåÊÑèÂú®Ë®ÄÂ§ñ„ÄÇ",
    "‰Ω†ÂÖ∂ÂÆûÂ∑≤ÁªèÁü•ÈÅìÁ≠îÊ°à‰∫Ü„ÄÇ",
    "ÈóÆÈ¢òÂ§™Ê®°Á≥äÔºåËÄÅÁà∑Âê¨‰∏çÊáÇ„ÄÇ",
    "‰∏îÊîæÂÆΩÂøÉÔºå‰∏ÄÁ¨ëÁΩÆ‰πã„ÄÇ"
];

const WENBEI_MSGS = [
    "Êó∂ËøêÊú™Ëá≥ÔºåÂàáÂãøÂ¶ÑÂä®„ÄÇ",
    "ÂøÉËØöÂàôÁÅµÔºåÊùÇÂøµÂ§™Èáç„ÄÇ",
    "Ê≠§Ë∑Ø‰∏çÈÄöÔºåÂè¶ÂØª‰ªñÊ≥ï„ÄÇ",
    "Â§©Êú∫‰∏çÂèØÊ≥ÑÈú≤„ÄÇ",
    "ÊöÇÂÆàÊú¨ÂàÜÔºåÂãøÁîüË¥™Âøµ„ÄÇ",
    "ËÄÅÁà∑Âú®ÂøôÔºåÊîπÊó•ÂÜçÊù•„ÄÇ",
    "Ê≠§‰∫ã‰∏çÂèØ‰∏∫ÔºåÊÖé‰πã„ÄÇ",
    "ÈùôÂøÉ‰øÆÂæ∑ÔºåÁ¶èÊä•Ëá™Êù•„ÄÇ"
];

/**
 * Universal AI Caller (Supports OpenAI-Format, e.g. DeepSeek/Kimi/Gemini-Compat)
 */
async function callAI(type) {
    const effectiveKey = getEffectiveKey();
    
    if (!effectiveKey) {
        showSettings();
        return;
    }

    fortuneModal.style.display = 'flex';
    loadingView.style.display = 'flex';
    resultView.style.display = 'none';
    fortuneAiComment.style.display = 'none';
    
    const loadingTexts = ["ËÄÅÁà∑Ê≠£Âú®Êü•ÈòÖÂ§©‰π¶...", "È¶ôÁÉüË¢ÖË¢ÖÔºåÊ≤üÈÄöÂ§©Â∫≠...", "ËÄÅÁà∑Ê≠£Âú®ÊñüÈÖå...", "Âú£ÊùØËêΩÂú∞ÔºåÁ•ûÊú∫ÊòæÁé∞..."];
    loadingText.innerText = loadingTexts[Math.floor(Math.random() * loadingTexts.length)];

    // Get User Wish
    const userWish = wishInput.value.trim();
    let wishContext = "";
    if (userWish) {
        wishContext = ` The believer has a specific wish/question: "${userWish}". Please interpret the result specifically in the context of this wish.`;
    }

    let systemPrompt = "You are 'Lao Ye' (ËÄÅÁà∑), a wise, kind, and ancient Chaoshan/Teochew deity. Speak in Chinese. Be protective, authoritative but warm. Keep responses concise (under 60 words).";
    let userPrompt = "";
    
    if (type === "SHENGBEI") {
        const randomIndex = Math.floor(Math.random() * FORTUNES.length);
        currentFortune = FORTUNES[randomIndex];
        fortuneTitle.innerText = "‚ú® " + currentFortune.title + " ‚ú®";
        fortuneText.innerText = currentFortune.poem;
        userPrompt = `A believer drew the fortune sign: "${currentFortune.title}" with the poem: "${currentFortune.poem.replace(/\n/g, ', ')}".${wishContext} Provide a brief interpretation (Ëß£Á≠æ).`;
    } else if (type === "XIAOBEI") {
        const randomIndex = Math.floor(Math.random() * XIAOBEI_MSGS.length);
        const msg = XIAOBEI_MSGS[randomIndex];
        fortuneTitle.innerText = "‚òÅÔ∏è ËÄÅÁà∑Á¨ë‰∫Ü ‚òÅÔ∏è";
        fortuneText.innerText = msg;
        userPrompt = `The believer threw 'Xiaobei' (Laughing Cup). You said: "${msg}".${wishContext} Briefly explain why you are laughing in a humorous way.`;
    } else {
        const randomIndex = Math.floor(Math.random() * WENBEI_MSGS.length);
        const msg = WENBEI_MSGS[randomIndex];
        fortuneTitle.innerText = "‚õ∞Ô∏è ËÄÅÁà∑‰∏çËØ≠ ‚õ∞Ô∏è";
        fortuneText.innerText = msg;
        userPrompt = `The believer threw 'Wenbei' (Stable Cup/Refusal). You said: "${msg}".${wishContext} Briefly explain why you refused in a stern way.`;
    }

    try {
        // Use DeepSeek / OpenAI Compatible Format
        // Note: Gemini also has an OpenAI-compatible endpoint now, but we focus on DeepSeek/Kimi structure
        const response = await fetch(DEFAULT_CONFIG.apiUrl, {
            method: 'POST',
            headers: { 
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${effectiveKey}`
            },
            body: JSON.stringify({ 
                model: DEFAULT_CONFIG.model,
                messages: [
                    { role: "system", content: systemPrompt },
                    { role: "user", content: userPrompt }
                ],
                stream: false
            })
        });

        const data = await response.json();
        
        if (data.error) throw new Error(data.error.message || JSON.stringify(data.error));
        
        // Handle standard OpenAI format response
        const text = data.choices[0].message.content;
        
        loadingView.style.display = 'none';
        resultView.style.display = 'block';
        fortuneAiComment.innerText = "„ÄêËÄÅÁà∑Á•ûÁ§∫„Äë\n" + text;
        fortuneAiComment.style.display = 'block';

    } catch (error) {
        console.error(error);
        loadingView.style.display = 'none';
        resultView.style.display = 'block';
        
        // Fallback messages for offline/error mode
        let fallbackMsg = "";
        if (type === "SHENGBEI") fallbackMsg = "„ÄêËÄÅÁà∑Á•ûÁ§∫„Äë\nÂøÉËØöÂàôÁÅµÔºåÊâÄÊ±Ç‰πã‰∫ãÂøÖÊúâÂõûÂìç„ÄÇÊ≠§Á≠æÂ§ßÂêâÔºåÂÆâÂøÉÂâçË°åÂç≥ÂèØ„ÄÇ";
        else if (type === "XIAOBEI") fallbackMsg = "„ÄêËÄÅÁà∑Á•ûÁ§∫„Äë\nËé´ÊÄ•Ëé´ÊÄ•ÔºåÊ≠§‰∫ãÁúãÊù•ÊÇ®ÂøÉ‰∏≠Êó©ÊúâÂÆöÊï∞Ôºå‰ΩïÂøÖÂÜçÈóÆÔºüÂºÄÂøÉ‰æøÂ•Ω„ÄÇ";
        else fallbackMsg = "„ÄêËÄÅÁà∑Á•ûÁ§∫„Äë\nÊó∂Êú∫Êú™Âà∞ÔºåÊöÇ‰∏î‰øÆË∫´ÂÖªÊÄßÔºåÂæÖÊó∂ËøêÊµÅËΩ¨ÂÜçÊù•ÈóÆËØ¢„ÄÇ";
        
        fortuneAiComment.innerText = fallbackMsg + "\n(ÁΩëÁªú‰∏ç‰Ω≥ÔºåÊòæÁ§∫Á¶ªÁ∫øËß£ËØª)";
        fortuneAiComment.style.display = 'block';
    }
}

function closeFortuneModal() {
    fortuneModal.style.display = 'none';
}

aiButton.addEventListener('click', (e) => {
    e.stopPropagation();
    callAI(resultType);
});


// --- Pixel Art Drawing ---
function drawRect(x, y, w, h, color) {
    ctx.fillStyle = color;
    ctx.fillRect(Math.floor(x), Math.floor(y), w, h);
}

const SHENGBEI_PIXELS = {
    flat: [
        [0,0,0,1,1,1,1,1,0,0,0,0], [0,0,1,1,1,2,2,2,1,0,0,0], [0,1,1,1,2,2,2,2,1,1,0,0],
        [1,1,1,1,2,2,2,2,1,1,1,0], [1,1,1,1,1,1,1,1,1,1,1,0], [1,1,1,1,0,0,0,0,1,1,1,0],
        [1,1,1,0,0,0,0,0,0,1,1,0], [1,1,0,0,0,0,0,0,0,1,1,0], [1,0,0,0,0,0,0,0,0,0,1,0],
        [0,0,0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0,0,0]
    ],
    round: [
        [0,0,0,1,1,1,1,1,0,0,0,0], [0,0,1,1,1,1,1,1,1,0,0,0], [0,1,1,1,2,2,1,1,1,1,0,0],
        [1,1,1,2,2,2,2,1,1,1,1,0], [1,1,1,2,2,2,2,1,1,1,1,0], [1,1,1,1,1,1,1,1,1,1,1,0],
        [1,1,1,0,0,0,0,0,0,1,1,0], [1,1,0,0,0,0,0,0,0,1,1,0], [1,0,0,0,0,0,0,0,0,0,1,0],
        [0,0,0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0,0,0]
    ],
    side: [
        [0,0,0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,0], [0,1,1,1,1,1,1,1,1,1,0,0], [1,1,1,1,1,1,1,1,1,1,1,0],
        [1,1,0,0,0,0,0,0,0,1,1,0], [1,0,0,0,0,0,0,0,0,0,1,0], [0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0,0,0]
    ]
};

function drawPixelSprite(x, y, grid, colorMap, scale = 2, rot = 0, auraColor = null) {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(rot);
    const offset = (grid.length / 2) * scale;
    if (auraColor) {
        ctx.shadowColor = auraColor;
        ctx.shadowBlur = 20;
        ctx.fillStyle = auraColor;
        ctx.beginPath();
        ctx.arc(0, 0, 15, 0, Math.PI*2);
        ctx.fill();
        ctx.shadowBlur = 0; 
    }
    for(let r=0; r<grid.length; r++) {
        for(let c=0; c<grid[0].length; c++) {
            const val = grid[r][c];
            if(val > 0) {
                ctx.fillStyle = colorMap[val];
                ctx.fillRect(c * scale - offset, r * scale - offset, scale, scale);
            }
        }
    }
    ctx.restore();
}

function drawLaoYe() {
    const cx = GAME_WIDTH / 2;
    const cy = 120;
    ctx.save();
    ctx.scale(2, 2);

    ctx.globalAlpha = 0.2 + Math.sin(animTime * 0.05) * 0.1;
    ctx.beginPath();
    ctx.arc(cx, cy, 60, 0, Math.PI * 2);
    ctx.fillStyle = COLORS.gold;
    ctx.fill();
    ctx.globalAlpha = 1.0;

    drawRect(cx - 30, cy, 60, 80, '#A62619');
    drawRect(cx - 10, cy, 20, 80, COLORS.gold);
    drawRect(cx - 40, cy + 5, 10, 30, '#801A10');
    drawRect(cx + 30, cy + 5, 10, 30, '#801A10');
    drawRect(cx - 15, cy - 35, 30, 35, '#E8C0A0');
    drawRect(cx - 15, cy - 35, 30, 10, 'black');
    drawRect(cx - 10, cy - 45, 20, 10, COLORS.gold);
    drawRect(cx - 10, cy - 5, 20, 25, 'white');
    drawRect(cx - 5, cy + 20, 10, 15, '#ddd');
    drawRect(cx - 8, cy - 20, 4, 2, 'black');
    drawRect(cx + 4, cy - 20, 4, 2, 'black');
    drawRect(0, 250, GAME_WIDTH, 100, COLORS.altar);
    drawRect(cx - 20, 240, 40, 20, '#CD7F32');
    drawRect(cx - 15, 235, 30, 5, '#A0522D');
    drawRect(cx - 5, 215, 2, 20, '#D2691E');
    drawRect(cx, 210, 2, 25, '#D2691E');
    drawRect(cx + 5, 215, 2, 20, '#D2691E');

    if (Math.floor(animTime) % 4 === 0) {
        if (Math.random() < 0.2) {
             particles.push({
                x: (cx * 2) + (Math.random() - 0.5) * 10,
                y: 420, 
                vx: (Math.random() - 0.5) * 0.5,
                vy: -0.5 - Math.random() * 0.5,
                life: 80,
                color: 'rgba(200,200,200,0.4)',
                size: 4 
            });
        }
    }
    ctx.restore();
}

function drawHands() {
    let yOffset = 0;
    if (gameState === STATE.CHARGING) yOffset = Math.sin(animTime * 0.8) * 2 + chargePower * 0.5;
    else if (gameState === STATE.THROWN) yOffset = 300; 
    else if (gameState === STATE.START) yOffset = Math.sin(animTime * 0.05) * 3;

    const lx = 80;
    const rx = 240;
    const by = 400 + yOffset;

    ctx.save();
    ctx.scale(2, 2);

    drawRect(lx - 20, by, 40, 40, COLORS.skin);
    drawRect(lx - 15, by - 5, 10, 20, COLORS.skin);
    drawRect(lx - 5, by - 10, 10, 20, COLORS.skin);
    drawRect(lx + 5, by - 8, 10, 18, COLORS.skin);
    drawRect(rx - 20, by, 40, 40, COLORS.skin);
    drawRect(rx + 5, by - 5, 10, 20, COLORS.skin);
    drawRect(rx - 5, by - 10, 10, 20, COLORS.skin);
    drawRect(rx - 15, by - 8, 10, 18, COLORS.skin);
    
    if (gameState === STATE.START || gameState === STATE.CHARGING) {
        const scale = 3;
        drawPixelSprite(lx + 5, by, SHENGBEI_PIXELS.side, {1: COLORS.red}, scale, -Math.PI/2);
        drawPixelSprite(rx - 5, by, SHENGBEI_PIXELS.side, {1: COLORS.red}, scale, Math.PI/2);
    }
    ctx.restore();
}

function drawPixelShengbei(cup) {
    let grid, colors;
    const scale = 3; 
    const rotation = cup.rot;
    
    let showFlat = false;

    // Determine current face
    if (cup.y >= FLOOR_Y && Math.abs(cup.vy) < 0.1) {
        showFlat = cup.isFlat;
    } else {
        const phase = Math.cos(rotation);
        showFlat = phase > 0;
    }
    
    // Choose Sprite
    if (Math.abs(Math.cos(rotation)) > 0.5) { 
        if (showFlat) {
            grid = SHENGBEI_PIXELS.flat;
            colors = {1: COLORS.wood, 2: '#F4D090'}; 
        } else {
            grid = SHENGBEI_PIXELS.round;
            colors = {1: COLORS.red, 2: '#FF5544'}; 
        }
    } else {
        grid = SHENGBEI_PIXELS.side;
        colors = {1: COLORS.red};
    }
    drawPixelSprite(cup.x, cup.y, grid, colors, scale, rotation);

    // --- Draw Text Only UI (No Icon) ---
    if (gameState === STATE.THROWN) {
        ctx.save();
        ctx.translate(cup.x, cup.y - 40); // Float above cup
        
        // Determine what the result would be NOW
        const wouldBeFlat = Math.cos(rotation) > 0;
        let label = wouldBeFlat ? "Âπ≥" : "Âá∏";
        
        // Style the text
        ctx.font = "bold 24px 'Ma Shan Zheng', sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        // Text Color matching the state
        ctx.fillStyle = wouldBeFlat ? COLORS.gold : COLORS.red;

        // Stroke for visibility
        ctx.strokeStyle = "black";
        ctx.lineWidth = 4;
        ctx.strokeText(label, 0, -10); 
        ctx.fillText(label, 0, -10);
        
        ctx.restore();
    }
}

function updateParticles() {
    for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life--;
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x, p.y, p.size, p.size);
        if (p.life <= 0) particles.splice(i, 1);
    }
}

function createExplosion(x, y, color) {
    for(let i=0; i<15; i++) {
        particles.push({
            x: x * 2, 
            y: y * 2,
            vx: (Math.random() - 0.5) * 6,
            vy: (Math.random() - 0.5) * 6,
            life: 30,
            color: color,
            size: 6
        });
    }
}

// --- Game Logic ---

function resetGame() {
    gameState = STATE.START;
    chargePower = 0;
    statusText.innerText = "Êåâ‰ΩèÁ©∫Ê†ºËìÑÂäõ";
    subText.style.display = "none"; 
    statusText.style.color = "white";
    wishInput.style.display = "block"; // Show input again
    aiLayer.style.display = 'none';
    resultType = "";
    currentFortune = null;
    cups.left = { x: 80, y: FLOOR_Y, vx: 0, vy: 0, rot: 0, rotSpeed: 0, isFlat: false };
    cups.right = { x: 240, y: FLOOR_Y, vx: 0, vy: 0, rot: 0, rotSpeed: 0, isFlat: false };
}

function throwCups() {
    gameState = STATE.THROWN;
    subText.style.display = "block"; 
    // Do not hide wish input immediately if user wants to see it, 
    // or hide it to declutter. Let's hide it for cleaner view.
    wishInput.style.display = "none"; 
    
    const power = 14 + (chargePower / 100) * 4; 
    
    cups.left.x = 80;
    cups.left.y = 400; 
    cups.left.vy = -power;
    cups.left.vx = 0.5 + Math.random() * 1.5; 
    cups.left.rotSpeed = 0.1 + Math.random() * 0.1;
    
    cups.right.x = 240;
    cups.right.y = 400;
    cups.right.vy = -power;
    cups.right.vx = -(0.5 + Math.random() * 1.5);
    cups.right.rotSpeed = -(0.1 + Math.random() * 0.1);
    
    statusText.innerText = "Á©∫‰∏≠Êåâ ‚Üê ‚Üí ÁøªËΩ¨!";
}

function checkResult() {
    const leftFlat = cups.left.isFlat;
    const rightFlat = cups.right.isFlat;
    subText.style.display = "none";
    
    setTimeout(() => {
        gameState = STATE.RESULT;
        aiLayer.style.display = 'flex'; 
        
        if (leftFlat !== rightFlat) {
            resultType = "SHENGBEI";
            statusText.innerText = "‚òÖ ËÉúÊùØÔºÅËÄÅÁà∑‰øùÂè∑ ‚òÖ";
            statusText.style.color = "#FFD700";
            aiButton.innerText = "‚ú® Ê±ÇÊîØÁÅµÁ≠æ ‚ú®";
            createExplosion(GAME_WIDTH/2, 150, COLORS.gold);
        } else if (!leftFlat && !rightFlat) {
            resultType = "WENBEI";
            statusText.innerText = "Á®≥ÊùØ (‰∏§Âá∏/Èò¥)";
            statusText.style.color = "#D93829";
            aiButton.innerText = "‚õ∞Ô∏è ËØ¢ÈóÆËÄÅÁà∑ ‚õ∞Ô∏è";
        } else {
            resultType = "XIAOBEI";
            statusText.innerText = "Á¨ëÊùØ (‰∏§Âπ≥/Èò≥)";
            statusText.style.color = "#E5C087";
            aiButton.innerText = "‚òÅÔ∏è ËÄÅÁà∑‰∏∫‰ΩïÂèëÁ¨ë? ‚òÅÔ∏è";
        }
    }, 500);
}

function updatePhysics(dt) {
    if (gameState === STATE.THROWN || gameState === STATE.BOUNCING) {
        
        let physicsDt = dt; 

        let settledCount = 0;
        [cups.left, cups.right].forEach((cup) => {
            // Apply Gravity
            if (cup.y < FLOOR_Y) cup.vy += GRAVITY * physicsDt;
            
            // Apply Velocity
            cup.x += cup.vx * physicsDt;
            cup.y += cup.vy * physicsDt;
            cup.rot += cup.rotSpeed * physicsDt;
            
            // Walls
            if (cup.x < 30 || cup.x > GAME_WIDTH - 30) cup.vx *= -0.5;
            
            // Floor Collision
            if (cup.y >= FLOOR_Y) {
                cup.y = FLOOR_Y;
                if (Math.abs(cup.vy) > 1.5) { 
                    cup.vy *= -0.4; 
                    // Exponential friction decay relative to time step
                    cup.vx *= Math.pow(0.8, physicsDt); 
                } else {
                    cup.vy = 0;
                    cup.vx = 0;
                    cup.rotSpeed = 0;
                    const phase = Math.cos(cup.rot);
                    cup.isFlat = phase > 0; 
                    cup.rot = cup.isFlat ? 0 : Math.PI; 
                }
            }
            if (cup.vy === 0 && cup.y === FLOOR_Y) settledCount++;
        });
        
        if (settledCount === 2 && gameState !== STATE.BOUNCING && gameState !== STATE.RESULT) {
            gameState = STATE.BOUNCING; 
            checkResult();
        }
    }
}

function flipCup(side) {
    if (gameState !== STATE.THROWN) return;
    const cup = side === 'left' ? cups.left : cups.right;
    
    cup.rotSpeed += (side === 'left' ? 0.3 : -0.3);
    cup.rot += Math.PI / 2; 
    cup.vy -= 2.5; 
    
    // Feedback effect
    createExplosion(cup.x, cup.y, 'white'); 
}

function update(dt) {
    animTime += dt;

    if (gameState === STATE.START) {
        if (keys.space) {
            gameState = STATE.CHARGING;
            chargePower = 0;
        }
    } else if (gameState === STATE.CHARGING) {
        if (keys.space) {
            chargePower += chargeDir * 2 * dt;
            if (chargePower > 100 || chargePower < 0) chargeDir *= -1;
        } else {
            throwCups();
        }
    } else if (gameState === STATE.RESULT) {
        if (keys.space && fortuneModal.style.display === 'none' && settingsModal.style.display === 'none') {
            resetGame();
            keys.space = false;
        }
    }
    updatePhysics(dt);
}

function draw() {
    ctx.fillStyle = COLORS.bg;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    drawLaoYe(); 
    drawHands(); 
    if (gameState !== STATE.START && gameState !== STATE.CHARGING) {
        ctx.save();
        ctx.scale(2, 2);
        ctx.fillStyle = COLORS.shadow;
        [cups.left, cups.right].forEach(c => {
            const shadowScale = 1 - (FLOOR_Y - c.y)/300; 
            if (shadowScale > 0) {
                ctx.beginPath();
                ctx.ellipse(c.x, FLOOR_Y + 12, 12 * shadowScale, 6 * shadowScale, 0, 0, Math.PI*2);
                ctx.fill();
            }
        });
        drawPixelShengbei(cups.left);
        drawPixelShengbei(cups.right);
        ctx.restore();
    }
    if (gameState === STATE.CHARGING) {
        ctx.save();
        ctx.scale(2, 2);
        ctx.fillStyle = '#555';
        ctx.fillRect(110, 350, 100, 10);
        ctx.fillStyle = '#ff0';
        ctx.fillRect(110, 350, chargePower, 10);
        ctx.strokeStyle = '#fff';
        ctx.strokeRect(110, 350, 100, 10);
        ctx.restore();
    }
    updateParticles(); 
}

window.addEventListener('keydown', e => {
    if (e.code === 'Space') keys.space = true;
    if (e.code === 'ArrowLeft') { keys.left = true; flipCup('left'); }
    if (e.code === 'ArrowRight') { keys.right = true; flipCup('right'); }
});
window.addEventListener('keyup', e => {
    if (e.code === 'Space') keys.space = false;
    if (e.code === 'ArrowLeft') keys.left = false;
    if (e.code === 'ArrowRight') keys.right = false;
});
const handleTouch = (keyName, isDown) => {
    if (keyName === 'space') {
        keys.space = isDown;
        if(isDown && gameState === STATE.RESULT && fortuneModal.style.display === 'none' && settingsModal.style.display === 'none') {
            resetGame();
            keys.space = false;
        }
    }
    if (keyName === 'left' && isDown) flipCup('left');
    if (keyName === 'right' && isDown) flipCup('right');
};
if ('ontouchstart' in window) document.getElementById('mobile-controls').style.display = 'flex';
document.getElementById('btn-space').addEventListener('touchstart', (e) => { e.preventDefault(); handleTouch('space', true); });
document.getElementById('btn-space').addEventListener('touchend', (e) => { e.preventDefault(); handleTouch('space', false); });
document.getElementById('btn-left').addEventListener('touchstart', (e) => { e.preventDefault(); handleTouch('left', true); });
document.getElementById('btn-right').addEventListener('touchstart', (e) => { e.preventDefault(); handleTouch('right', true); });

// Initialize modals to hidden state immediately
// This fixes the issue where spacebar reset doesn't work locally because style.display is empty initially
fortuneModal.style.display = 'none';
settingsModal.style.display = 'none';

let lastTime = 0;
function loop(timestamp) {
    if (!lastTime) lastTime = timestamp;
    let deltaTime = timestamp - lastTime;
    if (deltaTime > 50) deltaTime = 50;
    lastTime = timestamp;
    const timeScale = deltaTime / 16.67;
    update(timeScale);
    draw();
    requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>
